\section{Future Work}

\preston{This is taken from the proposal.  Mostly unchanged except for fixing
parts that refer to the proposal itself.}

The ultimate goal of our future work on SEA and CrashSimulator is to build
a large, self-sustaining community of users.  
%To achieve this we have a
%plan that focuses on both improving the tool and making specific
%community building efforts.  In this section we detail what specifically
%needs to be done to accomplish both parts of this plan.
%
%
%In addition to new feature additions, CrashSimulator requires some updates to
%replace soon-to-be unsupported components.  This includes migration from 
%Python 2 to Python 3.  We have migrated several widely used projects that have 
%successfully migrated from Python 2 to 3, including TUF~\cite{TUFwebpage}.
%While this will take time, it does not pose substantial risk.
%\cappos{Python 2-3 is optional, cut if the space is needed.}
%
%dependency that requires updating is the processor architecture
%that CrashSimulator supports.  Because the tool performs its simulation
%work manipulating the memory and register values that contain the results
%and side effects of system calls, the initial version of the tool was
%constrained to only supporting x86, 32-bit systems in order to development
%time.  At this point, 64-bit systems (typically x86\_64) are the norm and
%many Linux distributions are reducing the effort put into their 32-bit
%flavors.  While it is possible to use CrashSimulator to test applications
%by re-compiling them for 32-bit x86, this reduces two of the tool's
%advantages -- the ``universal'' nature of its tests and its ability to test
%an application without its source code.  In order to avoid a cumbersome
%situation where is users must recompile their applications, CrashSimulator
%will be changed to support applications compiled for x86\_64.
%
%
%
There are three areas of improvement we propose in this work.  First, we
will work on the {\bf usability} of CrashSimulator, in both standalone 
applications and in integrations into common toolchains.  This is needed to 
make the tool more useful to developers.  Second, we will add {\bf security}
mechanisms to make it possible to safely execute mutators and checkers from 
untrusted sources.  Third,
we will build a website with mechanisms that share mutators and checkers in a 
{\bf community} manner.  We describe each of these in more detail below.


%\subsubsection{Tool Improvements and New Features}
%
%To make CrashSimulator more appealing to our target users we propose taking
%the following actions:


%JAC: This won't work.  You lose the meaning of the anomaly in most cases
% when moving to that level of abstraction.
%\subsubsection{Supporting new platforms}
%
%CrashSimulator has been shown to be successful at finding
%environmental bugs in Linux applications. While this is useful,
%there is a great deal of opportunity to find more interesting, impactful
%bugs by examining the environmental differences resulting from applications
%running on completely different operating systems.
%In order to find these
%bugs, CrashSimulator must be improved so that it can run on, and simulate
%anomalies present in, these additional platforms.  Initially we plan to
%support Windows and OS X.
%
%Key to realizing this support is dealing with the fact that each operating
%system provides different system calls.  For example, Linux uses {\tt
%open()} to open files while Windows provides {\tt NtOpenFile()}.  In their
%current form, checkers and mutators describe anomalies and expected
%application behavior in terms of Linux system calls.  Addressing this
%limitation means elevating this description to a higher level and
%implementing a layer to translate this description down to the actual
%system calls a given operating system provides.  Building upon the previous
%example, a higher level description in a mutator may specify an operation
%like ``open file'' which is translated to either {\tt open()} or {\tt
%NtOpenFile()} as is appropriate.
%
%An additional area for exploration is determining whether or not a given
%anomaly is able to be simulated on a given operating system.  If an anomaly
%only appears in the presence of a operating system feature , it would be an
%error to simulate it on operating systems where this feature is not
%present.  Classifying anomalies in terms of where it makes sense to
%simulate them would reduce the number of false positive reports the tool
%could make.


\subsection{Usability: Grouping and Prioritizing Anomalies}

Not every flaw found by CrashSimulator is equivalent.  An issue that only
impacts an obsolete, rarely used file system is much less impactful than
one that impacts the most popular file system.  Prioritizing anomalies
can be accomplished by grouping them into sets that representing each 
environments in which an application is expected to run. The more popular
the environment, the more the developer may want to be aware of the issue.
It may also be the case that developers want to prioritize fixing all 
critical issues for one environment over another.  For example a piece
of software used in the cloud may not need to worry about issues that will only
occur behind the great firewall of China, if no cloud environments are deployed in this location.


%Grouping by environment and letting the developer prioritize and filter 
%environments enables much better developer control and increases the useful
%true positive rate of CrashSimulator.
%For example, the corpus of anomalies included with a future version of CrashSimulator
%could be segregated into groups such as those present on Windows 10, those
%present on Ubuntu 18.04 and so on.  Once grouped in this fashion,
%applications could be tested against a chosen group in order to see how it
%would perform on the represented operating system without. In this way,
%CrashSimualtor could offer insights into how an application will perform on
%a given operating system without having to go through of the effort of
%deploying it.
%
%

\subsubsection{Usability: Integration into CI platforms}

As with other tools, CrashSimulator is only effective when used.  Modern 
development processes include a continuous integration system, such as TravisCI
and CircleCI, to run tests automatically.  CI systems are popular because they
ensure that applications are continually and thoroughly tested as new code
contributions are submitted.  Given the ``universal'' nature of
CrashSimulator's testing process, the tool is a perfect fit for this
scenario.  Our goal is to provide a configuration of CrashSimulator,
suitable for unattended execution, to which test jobs can be submitted
automatically, as part of a continuous integration pipeline.  Once created,
this configuration would allow for testing with a
pre-selected set of anomalies by simply checking a box in the projects
testing configuration.

We believe this setup could drive rapid growth in CrashSimulator's
community because it removes most of the friction associated with adopting
a new tool.  Once the ``automated'' version of the tool is in place, it is a
natural next step for users to move into more advanced use cases and,
ideally, contribute to the tool as their needs expand.  Further, by
integrating with existing continuous integration infrastructure,
CrashSimulator gains access to those platforms' communities, giving the tool access to users who might not have otherwise found it.  The end result of all this is a new, expanded, set of community
members that can contribute to its continued improvement.


\subsubsection{Security: Sandboxing}

One of our main goals is to have a
CrashSimulator's community contribute to the corpus of anomalies the tool
can simulate.  In order to do this safely, the tool needs to be able to
take code from unknown, potential untrusted developers and execute it
without the possibility of negative effects on the host system, whether its unintentional bugs or
malicious actions.  

Our approach to offering this capability is
to execute checkers and mutators written in our description language in a
sandbox, which isolates Python code.  We propose to use the Python-Based Repy 
sandbox~\cite{Cappos_CCS_2010}, which was used in the 
Seattle testbed across tens of thousands of devices.  The Repy sandbox
has been designed to execute a minimal subset of Python in a secure manner.
Additionally, the Repy sandbox was designed expressly to integrate into 
existing programs like CrashSimulator, and has a proven track record of integrations into several
other large software projects.


The API provided in the sandbox will provide the
stream of system calls from the application being tested to the mutators and checker.  This includes
a native ability to traverse backwards through some guaranteed number of prior
calls.  The mutator or checker may respond with either the {\tt accept} or
{\tt reject} result of the state it perceives and keeps.  These limitations
dramatically reduce the ability of third-party checkers and mutators to
interact with the host system in unintended ways.

Repy can also offer further protection by enforcing resource limitations on 
the checkers and mutators running within it.  For example,
it may be useful to impose memory or processing limits in order to prevent
long running or poorly implemented checkers and mutators from harming the
stability of the host system.  Repy already has these 
capabilities~\cite{Li_USENIX_2015}, which will both improve the
tool's safety and ease of use on the small scale, and help speed
community building by reducing the effort required to vet
community submissions.

%Furthermore, we believe the effort of actually writing a checker and mutator
%in the sandbox will be dramatically reduced in Repy.  Much of the
%complexity associated with constructing these elements currently comes down
%to their being implemented in fully featured python.  Repy has demonstrated
%a remarkable ability to make writing many programs simpler by having a clean
%API and removing complexity from the language itself.
%%could be reduced through the use of a simpler checker and mutator
%%description language description language.  As we have discussed in more
%%detail elsewhere in this document, our plans consists of a language akin to
%%regular expressions focusing on sequences of system calls and their
%%arguments rather than the contents of strings.  
%Proof of concept
%experiments with this design have shown promise both in terms of
%feasibility of implementation and in real benefits to the anomaly encoding
%process.  




%\subsubsection{Usability Improvements}
%\cappos{2}
%
%Other improvements we propose will directly benefit CrashSimulator's
%usability.  The primary developer effort associated with using
%CrashSimulator is in constructing the checkers and mutators that drive its
%testing process.  In much the same vein as a constructing a unit test, the
%analysis effort required to produce these artifacts is closely tied to an
%individual user's skill and difficult to improve through technical means.


%\subsubsection{Updating components}

\subsubsection{Community: Building a Community Repository}

As was mentioned previously, our main goal is to foster a community around
CrashSimulator and SEA.  The community that grows around a tool or
technique is likely an even bigger contributor to its long term success
than its technical merits.  This is especially true in the case of SEA and
CrashSimulator due to the way the tool and technique become more effective
as users contribute to the corpus of anomalies that can be simulated.  

One of the primary advantages offered by SEA and CrashSimulator is the way
their effectiveness and capabilities can be augmented by the addition of
new anomalies.  To best take advantage of this fact it makes sense to
provide to users as many anomalies as is feasible in an easily accessible
fashion.  In the simplest case, this involves supplying a set of
straightforward anomalies that are known to be useful in testing a wide
variety of applications directly with the tool.
However, as the number of anomalies being contributed grows, this approach
will not scale.  Shipping a large number of anomalies, including some 
which will likely be useful only in specific situations, will harm the
tool's performance and user experience.  To address this problem, we
propose establishing an online anomaly repository.

An online anomaly repository can act as a centralized location for anomaly
metadata, such as
the operating systems on which they appear,
their performance characteristics, and the sorts of applications
with which they are likely to be useful.  Additionally, it could also
act as centralized location for community-driven anomaly documentation
and discussion.  This information would allow users to be informed enough
to download the individual anomalies or sets of anomalies that are most
useful for their specific use case.

Users will also be able to rate checkers and mutators, and report instances
of false positives to developers.  This is modeled after the Python Package
Index.  Users can quickly like or dislike
checkers and mutators that work for them to help the community find effective
tools.

The community repository will also have potential remediations linked to  
the CrashSimulator tool.  For example, when a bug report about a
socket {\tt O\_NONBLOCK} flag inheritence is received, the user would be linked to the Python
bug tracker's detailed report of the issue, along with the example fix that
patches the bug.  This information helps developers fix the 
bugs that CrashSimulator finds in a more timely manner.


%\subsubsection{Giving New Features Back to the Community}
%
%Part of the effort of developing CrashSimulator was making modifications to
%the {\tt rr} record-and-replay debugger.  Specifically, these changes
%allowed for two new features: the output of strace-style recordings and the
%ability to clone process sets as discussed in the SEA paper.  We propose
%giving these features back to the {\tt rr} community by porting them
%into main-line {\tt rr}.  Doing so would benefit {\tt rr}'s
%users by allowing them access to these new capabilities and would help
%CrashSimulator by ensuring that functionality on which it depends will
%continue to exist as {\tt rr} continues to grow and improve.


%\end{document}


%  Documentation on identifying and capturing anomalies
%  Product evangelism
%  User study
%  Wider instruction on selecting and capturing anomalies
